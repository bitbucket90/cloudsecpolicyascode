policy_keys = ["broad_policies_requiredresourcetags", "sqs_sqsstandards", "apigateway_apigatewaystandards", "efs_efsstandards"]
policy_list = {"broad_policies_requiredresourcetags": {"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "Required-Resource-Tags", "policy_set_description": "Policies to Enforce Tagging on all resources where applicable", "policy_engine": "opa", "workspace_ids": [], "is_global": true, "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "workspace_inclusions": [], "policies": {"storage-device-tagging": {"policy_name": "storage-device-tagging", "policy_description": "Storage Services Must Include Tag 'data-type' and 'data-classification'", "opa_query": "data.terraform.policies.tags.storage.deny", "enforcement_mode": "advisory", "policy_code": "package terraform.policies.storage_tag\n\nimport input.plan as plan\n\nmetadata := {\n    \"policy\": \"aws.tags.storage\",\n    \"description\": \"Storage Services Must Include Tag 'data-type' and 'data-classification'\",\n    \"policy_definition\": \"\",\n    \"severity\": \"medium\",\n    \"resourceTypes\": [\"aws_s3_bucket\",\"aws_efs_file_system\",\"aws_db_instance\"],\n    \"requiredTags\": [\"data-classification\",\"data_type\"],\n    \"resourceType\":\"\"\n}\n\ndeny[msg] {\n    resource := plan.resource_changes[_]\n    resource.type == \"aws_s3_bucket\" #metadata[\"resourceTypes\"][_]#storage_resource_types[_]\n    required_tags := {\"data-classification\", \"data-type\"}\n    provided_tags := {tag | resource.change.after.tags[tag]}\n    missing_tags := required_tags - provided_tags\n    count(missing_tags) > 0\n    msg := {\n       \"status\":\"Failed\",\n       \"resourceAddress\": resource.address,\n       \"policy\": metadata.policy,\n       \"description\": metadata.description,\n       \"severity\": metadata.severity,\n       \"remediation\": metadata.description\n    }\n}"}}, "policy_keys": ["storage-device-tagging"]}, "sqs_sqsstandards": {"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "SQS-Standards", "policy_set_description": "Policies to Enforce SQS Standards", "policy_engine": "opa", "workspace_ids": ["ws-XQp9EHDoBJGSA75K", "ws-xAS8aEXtnk9namB2"], "is_global": true, "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "workspace_inclusions": [], "policies": {"sqs-no-public-access": {"policy_name": "sqs-no-public-access", "policy_description": "Restrict traffic to within own AWS account", "opa_query": "data.aws.sqs.no_public_access.deny", "enforcement_mode": "mandatory", "policy_code": "package aws.sqs.no_public_access\nimport rego.v1\n\n# Restrict traffic to within own AWS account\n\n# Runbook link\n# https://github.com/open-itg/aws_runbooks/blog/master/sqs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue#policy\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue_policy\n\n# AWS link to policy definition/explanation\n# https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-using-identity-based-policies.html\n# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-principalaccount\n# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount\n\nmetadata := {\n    \"policy\": \"aws.sqs.no_public_access\",\n    \"description\": \"Restrict traffic to within own AWS account\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/opa/policies/sqs/no_public_access.rego\",\n    \"severity\": \"high\",\n    \"resourceTypes\": [\"aws_sqs_queue\", \"aws_sqs_queue_policy\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\nqueues := get_resources_by_type(\"aws_sqs_queue\", input.plan.resource_changes)\npolicies := get_resources_by_type(\"aws_sqs_queue_policy\", input.plan.resource_changes)\n\nis_in_scope(resource) if {\n\tresource.mode == \"managed\"\n\tis_resource_create_or_update(resource)\n}\n\n#\n# returns true if the specified queue has an inline policy\n#\nqueue_has_inline_policy(queue, plan) if {\n    # ensure the queue doesn't have an associated 'aws_sqs_queue_policy' resource\n    not queue_has_policy(queue, plan)\n\n    queue.change.after.policy != \"\"\n    queue.change.after.policy != null\n}\n\n#\n# returns true if the specified queue has an associated 'aws_sqs_queue_policy' resource\n#\nqueue_has_policy(queue, plan) if {\n    # case 1 - queue defined in a module (or nested module)\n    has(queue, \"module_address\")\n    config_queue_policy := find_configuration_resources_by_type_and_module(\n        \"aws_sqs_queue_policy\",\n        queue.module_address,\n        input.plan\n    )[_]\n    queue_without_module_prefix := substring(\n        queue.address,\n        count(queue.module_address) + 1,\n        count(queue.address)\n    )\n    queue_without_module_prefix in config_queue_policy.expressions.queue_url.references\n} else if {\n    # case 2 - queue defined in the root module\n\tnot has(queue, \"module_address\")\n    config_queue_policy := find_configuration_resources_by_type(\"aws_sqs_queue_policy\", plan)[_]\n\tqueue.address in config_queue_policy.expressions.queue_url.references\n} else := false if {\n    true\n}\n\n#\n# returns true if the specified inline policy is valid\n#\nhas_valid_inline_policy(policy_string) := true if {\n    policy := json.unmarshal(policy_string)\n    statements := policy.Statement\n    count([ statement |\n        statement := statements[_]\n        policy_has_account_condition_key(statement)\n    ]) == count(statements)\n}\n\npolicy_has_account_condition_key(statement) if {\n    statement.Effect == \"Allow\"\n    statement.Condition.StringEquals[\"aws:PrincipalAccount\"]\n} else if {\n    statement.Effect == \"Deny\"\n    statement.Condition.StringNotEquals[\"aws:PrincipalAccount\"]\n} else := false if {\n\ttrue\n}\n\nlookup_iam_policy(data_resource_address, queue_policy) := data_policy if {\n    # case 1 - data resource lives inside module (or nested module)\n    has(queue_policy, \"module_address\")\n    data_resource := find_configuration_resource_by_address_and_module(data_resource_address, queue_policy.module_address, input.plan)\n    data_policy := data_resource[0].expressions.statement\n} else := data_policy if {\n    # case 2 - data resource live in root module\n    data_resource := get_resources_by_address(data_resource_address, input.plan.configuration.root_module.resources)\n    data_resource != []\n    data_policy := data_resource[0].expressions.statement\n}\n\n# looks up the data reference for the policy\nfind_data_reference(config_queue_policy) := data_reference if {\n    references := config_queue_policy.expressions.policy.references\n    reference := references[_]\n    startswith(reference, \"data.\")\n    not endswith(reference, \".json\")\n    data_reference := reference\n} else := false if {\n    true\n}\n\n\n# ensure each statement has proper condition key elasticfilesystem:AccessedViaMountTarget with a value of true\nhas_valid_policy(statements) := true if {\n    count([statement |\n        statement := statements[_]\n        policy_has_condition_key(statement)\n    ]) == count(statements)\n}\n\npolicy_has_condition_key(statement) if {\n    statement.effect[\"constant_value\"] == \"Allow\"\n    condition := statement.condition[_]\n    condition.test[\"constant_value\"] == \"StringEquals\"\n    condition.variable[\"constant_value\"] == \"aws:PrincipalAccount\"\n} else if {\n    statement.effect[\"constant_value\"] == \"Deny\"\n    condition := statement.condition[_]\n    condition.test[\"constant_value\"] == \"StringNotEquals\"\n    condition.variable[\"constant_value\"] == \"aws:PrincipalAccount\"\n} else := false if {\n\ttrue\n}\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\n#\n# rule 1: ensure all SQS queues have a resource policy attached.\n#\nviolations contains reason if {\n\tqueue := queues[_]\n    is_in_scope(queue)\n\tnot queue_has_inline_policy(queue, input.plan)\n\tnot queue_has_policy(queue, input.plan)\n\treason := sprintf(\"AWS-SQS-NO_PUBLIC_ACCESS: SQS resource '%v' does not have a resource policy attached.\", [queue.address])\n}\n\n#\n# rule 2: ensure inline policies are valid\n#\nviolations contains reason if {\n    queue := queues[_]\n    is_in_scope(queue)\n    queue_has_inline_policy(queue, input.plan)\n    not has_valid_inline_policy(queue.change.after.policy)\n    reason := sprintf(\"AWS-SQS-NO_PUBLIC_ACCESS: SQS resource '%v' has an invalid inline policy.\", [queue.address])\n}\n\n#\n# rule 3: ensure all non-inline policies are valid\n#\nviolations contains reason if {\n    queue_policy := policies[_]\n    is_in_scope(queue_policy)\n    # lookup the queue policy in config\n    config_queue_policy := find_configuration_resource(queue_policy, input.plan)\n    # find the data reference address for the policy\n    config_policy_reference := find_data_reference(config_queue_policy)\n    # lookup data resource and extract iam policy\n    iam_policy := lookup_iam_policy(config_policy_reference, queue_policy)\n    # validate policy\n    not has_valid_policy(iam_policy)\n    reason := sprintf(\"AWS-SQS-NO_PUBLIC_ACCESS: SQS resource policy '%v' is invalid.\", [queue_policy.address])\n}\n\ndeny := [ msg |\n    count(violations) != 0\n    msg := {\n        \"decision\": \"fail\",\n        \"violations\": violations,\n        \"metadata\": metadata,\n    }\n]\n\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}}, "policy_keys": ["sqs-no-public-access"]}, "apigateway_apigatewaystandards": {"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "API-Gateway-Standards", "policy_set_description": "Policies to Enforce API Gateway Standards", "policy_engine": "opa", "workspace_ids": ["ws-XQp9EHDoBJGSA75K", "ws-xAS8aEXtnk9namB2"], "is_global": true, "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "workspace_inclusions": [], "policies": {"apigateway-private-endpoints": {"policy_name": "apigateway-private-endpoints", "policy_description": "API Gateway resource should not be publicly accessible", "opa_query": "data.aws.apigateway.private_endpoints.deny", "enforcement_mode": "mandatory", "policy_code": "package aws.apigateway.private_endpoints\n\nimport rego.v1\n\n# API Gateway resource should not be publicly accessible\n\n# Runbook link\n# https://github.com/cg-open-itg/aws_runbooks/blog/master/efs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_rest_api\n\n# AWS link to policy definition/explaination\n# https://aws.amazon.com/api-gateway/\n\nmetadata := {\n    \"policy\": \"aws.apigateway.private_endpoints\",\n    \"description\": \"API Gateway resource should not be publicly accessible\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/policy/aws/apigateway/private_endpoints.rego\",\n    \"severity\": \"high\",\n    \"resourceTypes\": [\"aws_api_gateway_rest_api\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\n\nallowed_endpoint_configuration_types := \"PRIVATE\"\n\nis_in_scope(resource) if {\n    resource.mode == \"managed\"\n\tis_create_or_update(resource.change.actions)\n    resource.type == \"aws_api_gateway_rest_api\"\n}\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource)\n    endpoint_configuration := resource.change.after.endpoint_configuration[_]\n    not allowed_endpoint_configuration_types in endpoint_configuration.types\n    message := \"AWS-APIGATEWAY-PRIVATE_ENDPOINTS: API Gateway resource '%s' should not be publicly accessible. Set endpoint_configuration_types as PRIVATE\"\n    reason := sprintf(message, [resource.address])\n}\n\ndeny := [ msg |\n  count(violations) != 0\n  msg := {\n    \"decision\": \"fail\",\n    \"violations\": violations,\n    \"metadata\": metadata\n  }\n]\n\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}, "apigateway-encryption": {"policy_name": "apigateway-encryption", "policy_description": "Enforce encryption if caching is enabled in REST API", "opa_query": "data.aws.apigateway.encryption.deny", "enforcement_mode": "mandatory", "policy_code": "package aws.apigateway.encryption\n\nimport rego.v1\n\n# Enforce encryption if caching is enabled in REST API\n\n# Runbook link\n# https://github.com/cg-open-itg/aws_runbooks/blog/master/efs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_method_settings\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_stage\n\n# AWS link to policy definition/explaination\n# https://aws.amazon.com/api-gateway/\n\nmetadata := {\n    \"policy\": \"aws.apigateway.encryption\",\n    \"description\": \"Enforce encryption if caching is enabled in REST API\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/policy/aws/apigateway/encryption.rego\",\n    \"severity\": \"medium\",\n    \"resourceTypes\": [\"aws_api_gateway_stage\", \"aws_api_gateway_method_settings\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\n\ncontains_terraform_resource(array, value) if {\n\tarray[_].type = value\n}\n\nis_cache_cluster_enabled(resource) if {\n    is_create_or_update(resource.change.actions)\n    resource.mode == \"managed\"\n    resource.change.after.cache_cluster_enabled == true\n}\n\nis_cache_data_encrypted(resource) if {\n\tresource.mode == \"managed\"\n\tis_create_or_update(resource.change.actions)\n    method_settings := resource.change.after.settings[_]\n    method_settings.cache_data_encrypted == true\n}\n\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n\t[path1, api_gw_stage] := walk(resource)\n\tapi_gw_stage.type == \"aws_api_gateway_stage\"\n\tis_cache_cluster_enabled(api_gw_stage)\n    not contains_terraform_resource(input.plan.resource_changes, \"aws_api_gateway_method_settings\")\n\tmessage := \"AWS-APIGATEWAY-ENCRYPTION: If cache_cluster_enabled is set to true, then cache_data_encrypted must also be set to true. Set this parameter using aws_api_gateway_method_settings resource. '%s'\"\n    reason := sprintf(message, [api_gw_stage.address])\n}\n\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n\t[path1, api_gw_stage] := walk(resource)\n\tapi_gw_stage.type == \"aws_api_gateway_stage\"\n\tis_cache_cluster_enabled(api_gw_stage)\n    [path2, api_gw_method_settings] := walk(input.plan.resource_changes)\n    contains_terraform_resource(input.plan.resource_changes,\"aws_api_gateway_method_settings\")\n    api_gw_method_settings.type == \"aws_api_gateway_method_settings\"\n    not is_cache_data_encrypted(api_gw_method_settings)\n    message := \"AWS-APIGATEWAY-ENCRYPTION: If cache_cluster_enabled is set to true then cache_data_encrypted must also be set to true. '%s'\"\n    reason := sprintf(message, [api_gw_stage.address])\n}\n\ndeny := [ msg |\n    count(violations) != 0\n    msg := {\n        \"decision\": \"fail\",\n        \"violations\": violations,\n        \"metadata\": metadata,\n    }\n]\n\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}, "apigateway-logging": {"policy_name": "apigateway-logging", "policy_description": "Restrict API deployment if logging is not enabled", "opa_query": "data.aws.apigateway.logging.deny", "enforcement_mode": "mandatory", "policy_code": "package aws.apigateway.logging\n\nimport rego.v1\n\n# Restrict API deployment if logging is not enabled\n\n# Runbook link\n# https://github.com/cg-open-itg/aws_runbooks/blog/master/docs/runbooks/efs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_method_settings\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_stage\n\n# AWS link to policy definition/explaination\n# https://aws.amazon.com/api-gateway/\n\nmetadata := {\n    \"policy\": \"aws.apigateway.logging\",\n    \"description\": \"Restrict API deployment if logging is not enabled\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/policy/aws/apigateway/logging.rego\",\n    \"severity\": \"medium\",\n    \"resourceTypes\": [\"aws_api_gateway_method_settings\", \"aws_api_gateway_stage\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\n\nnot_allowed_logging_level := \"OFF\"\n\ncontains_terraform_resource(array, value) if {\n\tarray[_].type == value\n}\n\nis_logging_level_present(settings) if {\n    logging_level := settings.logging_level\n}\n\nis_logging_level_allowed(value) if {\n\tvalue != not_allowed_logging_level\n}\n\nis_in_scope(resource, type) if {\n\tresource.mode == \"managed\"\n\tis_create_or_update(resource.change.actions)\n\tresource.type == type\n}\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\n#\n# rule 1: All API Gateway stages must have logging set to either INFO or ERROR\n#\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource, \"aws_api_gateway_stage\")\n    not contains_terraform_resource(input.plan.resource_changes,\"aws_api_gateway_method_settings\")\n    message := \"AWS-APIGATEWAY-LOGGING: If aws_api_gateway_stage is created then aws_api_gateway_method_settings must be used with logging_level set to either INFO or ERROR '%s'\"\n    reason := sprintf(message, [resource.address])\n}\n\n#\n# rule 2: method settings should never have log level set to 'OFF'\n#\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource, \"aws_api_gateway_method_settings\")\n    settings := resource.change.after.settings[_]\n    is_logging_level_present(settings)\n    logging_level := settings.logging_level\n    not is_logging_level_allowed(logging_level)\n    message := \"AWS-APIGATEWAY-LOGGING: logging_level under aws_api_gateway_method_settings should not be OFF '%s'\"\n    reason := sprintf(message, [resource.address])\n}\n\n#\n# rule 3: Ensure that logging level is defined in method settings\n#\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource, \"aws_api_gateway_method_settings\")\n    settings := resource.change.after.settings[_]\n    not is_logging_level_present(settings)\n    message := \"AWS-APIGATEWAY-LOGGING:logging_level is not defined in aws_api_gateway_method_settings. Set logging_level as INFO or ERROR '%s'\"\n    reason := sprintf(message, [resource.address])\n}\n\ndeny := [ msg |\n    count(violations) != 0\n    msg := {\n        \"decision\": \"fail\",\n        \"violations\": violations,\n        \"metadata\": metadata,\n    }\n]\n\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}}, "policy_keys": ["apigateway-private-endpoints", "apigateway-encryption", "apigateway-logging"]}, "efs_efsstandards": {"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "EFS-Standards", "policy_set_description": "Policies to Enforce EFS Standards", "policy_engine": "opa", "workspace_ids": ["ws-XQp9EHDoBJGSA75K", "ws-xAS8aEXtnk9namB2"], "is_global": true, "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "workspace_inclusions": [], "policies": {"efs-no-public-access": {"policy_name": "efs-no-public-access", "policy_description": "Restrict public access to EFS file systems.", "opa_query": "data.aws.efs.no_public_access.deny", "enforcement_mode": "mandatory", "policy_code": "package aws.efs.no_public_access\nimport rego.v1\n\n# Restrict public access to EFS file systems\n\n# Runbook link\n# https://github.com/open-itg/aws_runbooks/blog/master/efs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/efs_file_system\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/efs_file_system_policy\n\n# AWS link to policy definition/explaination\n# https://docs.aws.amazon.com/efs/latest/ug/NFS-access-control-efs.html\n# https://docs.aws.amazon.com/efs/latest/ug/access-control-block-public-access.html#what-is-a-public-policy\n\nmetadata := {\n    \"policy\": \"aws.efs.no_public_access\",\n    \"description\": \"Restrict public access to EFS file systems\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/policy/efs/no_public_access.rego\",\n    \"severity\": \"high\",\n    \"resourceTypes\": [\"aws_efs_file_system\", \"aws_efs_file_system_policy\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\nfile_systems := get_resources_by_type(\"aws_efs_file_system\", input.plan.resource_changes)\nfile_system_policies := get_resources_by_type(\"aws_efs_file_system_policy\", input.plan.resource_changes)\n\nis_in_scope(resource) if {\n\tresource.mode == \"managed\"\n\tis_resource_create_or_update(resource)\n}\n\n# verify an associated policy exits\nfile_system_has_policy(file_system, plan) if {\n    # case 1 - file system defined in a module (or nested module)\n    config_file_system_policy := find_configuration_resources_by_type_and_module(\n        \"aws_efs_file_system_policy\",\n        file_system.module_address,\n        plan\n    )[_]\n    file_system_address_without_module_prefix := substring(\n        file_system.address,\n        count(file_system.module_address) + 1,\n        count(file_system.address)\n    )\n    file_system_address_without_module_prefix in config_file_system_policy.expressions.file_system_id.references\n} else if {\n    # case 2 - file system defined in the root module\n    config_file_system_policy := find_configuration_resources_by_type(\"aws_efs_file_system_policy\", plan)[_]\n    file_system.address in config_file_system_policy.expressions.file_system_id.references\n} else := false if {\n    true\n}\n\nlookup_iam_policy(data_resource_address, file_system_policy) := data_policy if {\n    # case 1 - data resource lives inside module (or nested module)\n    has(file_system_policy, \"module_address\")\n    data_resource := find_configuration_resource_by_address_and_module(data_resource_address, file_system_policy.module_address, input.plan)\n    data_policy := data_resource[0].expressions.statement\n} else := data_policy if {\n    # case 2 - data resource live in root module\n    data_resource := get_resources_by_address(data_resource_address, input.plan.configuration.root_module.resources)\n    data_resource != []\n    data_policy := data_resource[0].expressions.statement\n}\n\n# looks up the data reference for the policy\nfind_data_reference(config_file_system_policy) := data_reference if {\n    references := config_file_system_policy.expressions.policy.references\n    reference := references[_]\n    startswith(reference, \"data.\")\n    not endswith(reference, \".json\")\n    data_reference := reference\n} else := false if {\n    true\n}\n\n# ensure each statement has proper condition key elasticfilesystem:AccessedViaMountTarget with a value of true\nhas_valid_policy(statements) := true if {\n    count([statement |\n        statement := statements[_]\n        policy_has_condition_key(statement)\n    ]) == count(statements)\n}\n\npolicy_has_condition_key(statement) if {\n    statement.effect[\"constant_value\"] == \"Allow\"\n    condition := statement.condition[_]\n    condition.test[\"constant_value\"] == \"Bool\"\n    condition.variable[\"constant_value\"] == \"elasticfilesystem:AccessedViaMountTarget\"\n    condition.values[\"constant_value\"] == [\"true\"]\n} else if {\n    statement.effect[\"constant_value\"] == \"Deny\"\n    condition := statement.condition[_]\n    condition.test[\"constant_value\"] == \"Bool\"\n    condition.variable[\"constant_value\"] == \"elasticfilesystem:AccessedViaMountTarget\"\n    condition.values[\"constant_value\"] == [\"false\"]\n} else := false if {\n\ttrue\n}\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\n#\n# rule 1: ensure all EFS file systems have a resource policy attached.\n#\nviolations contains reason if {\n\tfile_system := file_systems[_]\n    is_in_scope(file_system)\n\tnot file_system_has_policy(file_system, input.plan)\n\treason := sprintf(\"AWS-EFS-NO_PUBLIC_ACCESS: EFS resource '%v' does not have a resource policy attached.\", [file_system.address])\n}\n\n#\n# rule 2: ensure that policies do not leverage jsonencode function\n#\nviolations contains reason if {\n    file_system_policy := file_system_policies[_]\n    is_in_scope(file_system_policy)\n    config_file_system_policy := find_configuration_resource(file_system_policy, input.plan)\n    not find_data_reference(config_file_system_policy)\n    reason := sprintf(\"AWS-EFS-NO_PUBLIC_ACCESS: EFS resource policy '%v' is invalid. Policy should not leverage jsonencode function.\", [file_system_policy.address])\n}\n\n#\n# rule 3: ensure resource policies are valid\n#\nviolations contains reason if {\n    file_system_policy := file_system_policies[_]\n    is_in_scope(file_system_policy)\n    # lookup the efs policy in config\n    config_file_system_policy := find_configuration_resource(file_system_policy, input.plan)\n    # find the data reference address for the policy\n    root_policy_reference := find_data_reference(config_file_system_policy)\n    # lookup data resource and extract iam policy\n    iam_policy := lookup_iam_policy(root_policy_reference, file_system_policy)\n    # validate policy\n    not has_valid_policy(iam_policy)\n    reason := sprintf(\"AWS-EFS-NO_PUBLIC_ACCESS: EFS resource policy '%v' is invalid.\", [file_system_policy.address])\n}\n\ndeny := [ msg |\n    count(violations) != 0\n    msg := {\n        \"decision\": \"fail\",\n        \"violations\": violations,\n        \"metadata\": metadata,\n    }\n]\n\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}}, "policy_keys": ["efs-no-public-access"]}}