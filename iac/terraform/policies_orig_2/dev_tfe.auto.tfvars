policy_keys = []
policy_list = [{"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "Required_Resource_Tags", "policy_set_description": "Policies to Enforce Tagging on all resources where applicable", "policy_engine": "opa", "workspace_ids": [], "is_global": true, "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "workspace_inclusions": [], "policies": [{"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "Required_Resource_Tags", "policy_set_description": "Policies to Enforce Tagging on all resources where applicable", "policy_engine": "opa", "workspace_ids": [], "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "policy_name": "storage-device-tagging", "policy_description": "Storage Services Must Include Tag 'data-type' and 'data-classification'", "opa_query": "data.terraform.policies.tags.storage.deny", "enforcement_mode": "advisory", "policy_code": "package terraform.policies.storage_tag\n\nimport input.plan as plan\n\nmetadata := {\n    \"policy\": \"aws.tags.storage\",\n    \"description\": \"Storage Services Must Include Tag 'data-type' and 'data-classification'\",\n    \"policy_definition\": \"\",\n    \"severity\": \"medium\",\n    \"resourceTypes\": [\"aws_s3_bucket\",\"aws_efs_file_system\",\"aws_db_instance\"],\n    \"requiredTags\": [\"data-classification\",\"data_type\"],\n    \"resourceType\":\"\"\n}\n\ndeny[msg] {\n    resource := plan.resource_changes[_]\n    resource.type == \"aws_s3_bucket\" #metadata[\"resourceTypes\"][_]#storage_resource_types[_]\n    required_tags := {\"data-classification\", \"data-type\"}\n    provided_tags := {tag | resource.change.after.tags[tag]}\n    missing_tags := required_tags - provided_tags\n    count(missing_tags) > 0\n    msg := {\n       \"status\":\"Failed\",\n       \"resourceAddress\": resource.address,\n       \"policy\": metadata.policy,\n       \"description\": metadata.description,\n       \"severity\": metadata.severity,\n       \"remediation\": metadata.description\n    }\n}"}]}, {"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "API_Gateway_Standards", "policy_set_description": "Policies to Enforce API Gateway Standards", "policy_engine": "opa", "workspace_ids": ["ws-XQp9EHDoBJGSA75K", "ws-xAS8aEXtnk9namB2"], "is_global": true, "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "workspace_inclusions": [], "policies": [{"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "API_Gateway_Standards", "policy_set_description": "Policies to Enforce API Gateway Standards", "policy_engine": "opa", "workspace_ids": ["ws-XQp9EHDoBJGSA75K", "ws-xAS8aEXtnk9namB2"], "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "policy_name": "apigateway-encryption", "policy_description": "Enforce encryption if caching is enabled in REST API", "opa_query": "data.aws.apigateway.encryption.violations", "enforcement_mode": "mandatory", "policy_code": "package aws.apigateway.encryption\n\nimport rego.v1\n\n# Enforce encryption if caching is enabled in REST API\n\n# Runbook link\n# https://github.com/cg-open-itg/aws_runbooks/blog/master/efs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_method_settings\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_stage\n\n# AWS link to policy definition/explaination\n# https://aws.amazon.com/api-gateway/\n\nmetadata := {\n    \"policy\": \"aws.apigateway.encryption\",\n    \"description\": \"Enforce encryption if caching is enabled in REST API\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/policy/aws/apigateway/encryption.rego\",\n    \"severity\": \"medium\",\n    \"resourceTypes\": [\"aws_api_gateway_stage\", \"aws_api_gateway_method_settings\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\n\ncontains_terraform_resource(array, value) if {\n\tarray[_].type = value\n} \n\nis_cache_cluster_enabled(resource) if {\n    is_create_or_update(resource.change.actions)\n    resource.mode == \"managed\"\n    resource.change.after.cache_cluster_enabled == true\n}\n\nis_cache_data_encrypted(resource) if {\n\tresource.mode == \"managed\"\n\tis_create_or_update(resource.change.actions)\n    method_settings := resource.change.after.settings[_]\n    method_settings.cache_data_encrypted == true\n}\n\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n\t[path1, api_gw_stage] := walk(resource)\n\tapi_gw_stage.type == \"aws_api_gateway_stage\"\n\tis_cache_cluster_enabled(api_gw_stage)\n    not contains_terraform_resource(input.plan.resource_changes, \"aws_api_gateway_method_settings\")\n\tmessage := \"AWS-APIGATEWAY-ENCRYPTION: If cache_cluster_enabled is set to true, then cache_data_encrypted must also be set to true. Set this parameter using aws_api_gateway_method_settings resource. '%s'\"\n    reason := sprintf(message, [api_gw_stage.address])\n}\n\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n\t[path1, api_gw_stage] := walk(resource)\n\tapi_gw_stage.type == \"aws_api_gateway_stage\"\n\tis_cache_cluster_enabled(api_gw_stage)\n    [path2, api_gw_method_settings] := walk(input.plan.resource_changes)\n    contains_terraform_resource(input.plan.resource_changes,\"aws_api_gateway_method_settings\")\n    api_gw_method_settings.type == \"aws_api_gateway_method_settings\"\n    not is_cache_data_encrypted(api_gw_method_settings)\n    message := \"AWS-APIGATEWAY-ENCRYPTION: If cache_cluster_enabled is set to true then cache_data_encrypted must also be set to true. '%s'\"\n    reason := sprintf(message, [api_gw_stage.address])\n}\n\ndeny := {\n\t\"decision\": decision,\n\t\"message\": message,\n\t\"metadata\": metadata,\n} if {\n\tcount(violations) > 0\n\tdecision = \"fail\"\n\tmessage := violations\n}\n\ndeny := {\n\t\"decision\": decision,\n\t\"message\": message,\n\t\"metadata\": metadata,\n} if {\n    count(violations) == 0\n\tdecision := \"pass\"\n\tmessage := \"AWS-APIGATEWAY-ENCRPYTION check passed.\"\n}\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}, {"organization": "sentinel-dev-testing", "organization_id": "org-1zGSHHZHJU29Lugt", "policy_set_name": "API_Gateway_Standards", "policy_set_description": "Policies to Enforce API Gateway Standards", "policy_engine": "opa", "workspace_ids": ["ws-XQp9EHDoBJGSA75K", "ws-xAS8aEXtnk9namB2"], "workspace_exclusions": ["ws-CoLUfqDa3bPCDR8a"], "policy_name": "apigateway-logging", "policy_description": "Restrict API deployment if logging is not enabled", "opa_query": "data.aws.apigateway.logging.violations", "enforcement_mode": "mandatory", "policy_code": "package aws.apigateway.logging\n\nimport rego.v1\n\n# Restrict API deployment if logging is not enabled\n\n# Runbook link\n# https://github.com/cg-open-itg/aws_runbooks/blog/master/docs/runbooks/efs/Runbook.md\n\n# Terraform policy resource link\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_method_settings\n# https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_stage\n\n# AWS link to policy definition/explaination\n# https://aws.amazon.com/api-gateway/\n\nmetadata := {\n    \"policy\": \"aws.apigateway.logging\",\n    \"description\": \"Restrict API deployment if logging is not enabled\",\n    \"policy_definition\": \"https://github.com/cg-open-itg/CloudSecPolicyAsCode/blog/master/policy/aws/apigateway/logging.rego\",\n    \"severity\": \"medium\",\n    \"resourceTypes\": [\"aws_api_gateway_method_settings\", \"aws_api_gateway_stage\"]\n}\n\n# ----------------------------------------------------------------------------------------------\n# Functions block\n# ----------------------------------------------------------------------------------------------\n\nnot_allowed_logging_level := \"OFF\"\n\ncontains_terraform_resource(array, value) if {\n\tarray[_].type == value\n} \n\nis_logging_level_present(settings) if {\n    logging_level := settings.logging_level\n}\n\nis_logging_level_allowed(value) if {\n\tvalue != not_allowed_logging_level\n} \n\nis_in_scope(resource, type) if {\n\tresource.mode == \"managed\"\n\tis_create_or_update(resource.change.actions)\n\tresource.type == type\n}\n\n# ----------------------------------------------------------------------------------------------\n# Deny block\n# ----------------------------------------------------------------------------------------------\n\n#\n# rule 1: All API Gateway stages must have logging set to either INFO or ERROR\n#\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource, \"aws_api_gateway_stage\")\n    not contains_terraform_resource(input.plan.resource_changes,\"aws_api_gateway_method_settings\")\n    message := \"AWS-APIGATEWAY-LOGGING: If aws_api_gateway_stage is created then aws_api_gateway_method_settings must be used with logging_level set to either INFO or ERROR '%s'\"\n    reason := sprintf(message, [resource.address])\n}\n\n#\n# rule 2: method settings should never have log level set to 'OFF'\n#\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource, \"aws_api_gateway_method_settings\")\n    settings := resource.change.after.settings[_]\n    is_logging_level_present(settings)\n    logging_level := settings.logging_level\n    not is_logging_level_allowed(logging_level)\n    message := \"AWS-APIGATEWAY-LOGGING: logging_level under aws_api_gateway_method_settings should not be OFF '%s'\"\n    reason := sprintf(message, [resource.address])\n}\n\n#\n# rule 3: Ensure that logging level is defined in method settings\n#\nviolations contains reason if {\n    resource := input.plan.resource_changes[_]\n    is_in_scope(resource, \"aws_api_gateway_method_settings\")\n    settings := resource.change.after.settings[_]\n    not is_logging_level_present(settings)\n    message := \"AWS-APIGATEWAY-LOGGING:logging_level is not defined in aws_api_gateway_method_settings. Set logging_level as INFO or ERROR '%s'\"\n    reason := sprintf(message, [resource.address])\n}\n\ndeny := {\n\t\"decision\": decision,\n\t\"message\": message,\n\t\"metadata\": metadata,\n} if {\n\tcount(violations) > 0\n\tdecision = \"fail\"\n\tmessage := violations\n}\n\ndeny := {\n\t\"decision\": decision,\n\t\"message\": message,\n\t\"metadata\": metadata,\n} if {\n    count(violations) == 0\n\tdecision := \"pass\"\n\tmessage := \"AWS-APIGATEWAY-LOGGING check passed.\"\n}\n#------------------------------------------------------------\n#Copied From Common Utils\n#------------------------------------------------------------\n\n\n# Checks if action is create or update\n# Common path: resource.change.actions\nis_create_or_update(change_actions) if {\n    change_actions[count(change_actions) - 1] == [\"create\", \"update\"][_]\n}\n\n# Checks of resource is being created or updated\nis_resource_create_or_update(resource) if {\n    is_create_or_update(resource.change.actions)\n}\n\n# Checks if path exists on object\nhas(object, path) if {\n    [obj_path, value] = walk(object)\n    obj_path == to_path(path)\n} else := false if {\n    true\n}\n\n# Check if every item in `match` array is present in `array`\ncontains_all(array, match) if {\n    count([value |\n        value := match[_]\n        value in array\n    ]) == count(match)\n} else := false if {\n    true\n}\n\n# Converts string path to a path array\nto_path(path) := output_array if {\n    output_array := [value |\n        part := split(path, \".\")[_]\n        value := _parse_array_index(part)\n    ]\n}\n\n_parse_array_index(value) := output if {\n    contains(value, \"[\")\n    number_string := substring(value, 1, count(value) - 2)\n    output = try_to_number(number_string)\n} else := output if {\n    output = value\n}\n\n# Attempts to converts string to a number\ntry_to_number(string) := out if {\n    out := to_number(string)\n} else := out if {\n    out := string\n}\n\n#  Gets the value at path of object.\nget(object, path) := output if {\n    [obj_path, value] = walk(object)\n    path_array := to_path(path)\n    obj_path == path_array\n    output := value\n}\n\n# ----------------------------------------------------------------------------------------------\n# Resource filtering functions\n# ----------------------------------------------------------------------------------------------\n\n# find configuration entries for resource\nfind_configuration_resource(resource, plan) := cfgresource if {\n    # case where there is no module\n    not resource.module_address\n    some ssm_resource\n    plan.configuration.root_module.resources[ssm_resource].address == resource.address\n    cfgresource := plan.configuration.root_module.resources[ssm_resource]\n} else := cfgresource if {\n    some ssm_resource\n    # case with module (or nested modules)\n    base_path := \"configuration.root_module\"\n    # get module_address and split with \".\"\n    module_address_list :=  split(resource.module_address, \".\")\n    # list comprehention to keep only modules names not \"module.\" entries\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    # rebuild path for configuration section\n    temp_path := concat(\".\", [ path2 | nested_module_path[i] ; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    temp_path2 := concat(\".\", [base_path, temp_path])\n\n    # search input object starting at root_module\n    myobj := get(plan, temp_path2)\n    concat(\".\", [resource.module_address, myobj.resources[ssm_resource].address]) == resource.address\n    cfgresource := myobj.resources[ssm_resource]\n}\n\nfind_configuration_resources_by_type_and_module(type, module_address, plan) := filtered_resources if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    filtered_resources := [\n        resource | \n        resource := myobj.resources[_]\n        resource.type == type\n    ]\n}\n\nfind_configuration_resource_by_address_and_module(address, module_address, plan) := cfgresource if {\n    # case with module (or nested modules)\n    # using module_address, convert to configuration path\n    module_address_list :=  split(module_address, \".\")\n    nested_module_path := [ path | module_address_list[i] != \"module\"; path :=  module_address_list[i] ]\n    temp_path := concat(\".\", [ path2 | nested_module_path[i]; path2 := sprintf(\"module_calls.%s.module\",[nested_module_path[i]])])\n    module_config_path := concat(\".\", [\"configuration.root_module\", temp_path])\n    # search input object starting at root_module\n    myobj := get(plan, module_config_path) \n    cfgresource := [\n        resource | \n        resource := myobj.resources[_]\n        resource.address == address\n    ]\n}\n\nfind_configuration_resources_by_type(type, plan) := filtered_resources if {\n    plan.configuration.root_module.resources\n    filtered_resources := get_resources_by_type(type, plan.configuration.root_module.resources)\n}\n\n# Get resources by type\nget_resources_by_type(type, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.type = type]\n}\n\n# Get resources by address\nget_resources_by_address(address, resources) := filtered_resources if {\n    filtered_resources := [resource | resource := resources[_]; resource.address = address]\n}\n"}]}]